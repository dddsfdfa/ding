# -*- coding: utf-8 -*-
"""[10+11] review

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yZ_bhwb4LQWSz_M68mDjr8uljF3-w_YH
"""

import torch
import math

"""### squeeze vs unsqueeze"""

a = torch.tensor(3)
a

a.size()

a.unsqueeze(-1).unsqueeze(1)

torch.randn([3,2,10]).unsqueeze(-1).size()

"""# Brownian Motion"""

def generate_brownian(n_paths, n_steps):

    dW = torch.randn(n_paths, n_steps)
    dW[:, 0] = 0.0
    W = dW.cumsum(dim=-1)

    return W

generate_brownian(2,5)

def generate_geometric_brownian(n_paths=2, n_steps=5, sigma=0.2, dt=1/250):

    t = torch.arange(n_steps) * dt
    W = generate_brownian(n_paths, n_steps)

    return torch.exp((-0.5 * sigma**2) * t + sigma *  torch.sqrt(torch.tensor(dt)) * W)

generate_geometric_brownian()

temp = generate_geometric_brownian()
temp.size()

temp.unsqueeze(1).size()

"""# Derivative payoff"""

def european_payoff(input, call=True, strike=1.0):

    if call:
        return torch.nn.functional.relu(input[..., -1] - strike)
    else:
        return torch.nn.functional.relu(strike - input[..., -1])

spot = generate_geometric_brownian()
spot

spot = spot.unsqueeze(1)
spot.size()

payoff = european_payoff(spot)
payoff

"""# profit and loss function (pl)"""

def pl(spot, unit, cost=None, payoff=None):

    output = unit[..., :-1].mul(spot.diff(dim=-1)).sum(dim=(-2,-1))

    if payoff is not None:
        pass

    if cost is not None:
        pass

    return output

spot.diff(dim=-1)

unit = torch.randn_like(spot)
unit

pl(spot, unit)

def pl(spot, unit, cost=None, payoff=None):

    output = unit[..., :-1].mul(spot.diff(dim=-1)).sum(dim=(-2,-1))

    if payoff is not None:
        output -= payoff.squeeze(-1)

    if cost is not None:
        pass

    return output

payoff = european_payoff(spot)
payoff.size()

pl(spot, unit, payoff=payoff)

def pl(spot, unit, cost=None, payoff=None):

    output = unit[..., :-1].mul(spot.diff(dim=-1)).sum(dim=(-2,-1))

    if payoff is not None:
        output -= payoff.squeeze(-1)

    if cost is not None:
        c = torch.tensor(cost).unsqueeze(0).unsqueeze(-1)
        output -= (spot[..., :-1].mul(unit.diff(dim=-1)).abs() * c).sum(dim=(-2, -1))

    return output

torch.tensor(0.1).unsqueeze(0).unsqueeze(-1)

unit = torch.randn_like(spot)
unit

pl(spot, unit, cost=0.1)

pl(spot, unit, cost= 0.1, payoff=payoff)

"""# Features"""

def time_to_maturity(spot, dt):

    n_paths, _, n_steps = spot.size()
    t = torch.arange(n_steps) * dt

    return (t[-1] - t).unsqueeze(0).expand(n_paths, 1, -1)

t = torch.arange(5) * 0.01
t

(t[-1] - t).unsqueeze(0).expand(2, 1, -1)

time_to_maturity(spot, 0.004)

def moneyness(spot, strike):
    return spot/strike

moneyness(spot, 1.1).size()

def log_moneyness(spot, strike):
    return torch.log(spot/strike)

log_moneyness(spot, 1.0)

def volatility(spot, vol):
    return torch.ones_like(spot) * vol

volatility(spot, 0.2)

"""# MLP"""

from torch import nn

class MLP(nn.Module):

    def __init__(self, n_inputs):
        super().__init__()

        self.model = nn.Sequential(
            nn.Linear(n_inputs, 512),
            nn.ReLU(),
            nn.Linear(512, 512),
            nn.ReLU(),
            nn.Linear(512, 512),
            nn.ReLU(),
            nn.Linear(512,1)
        )

    def forward(self, x):

        out = self.model(x)

        return out

m = MLP(3)

m

x = torch.randn(3)
m(x)

m.__call__(x)

"""# Dataset

### Practice
"""

from torch.utils.data import Dataset, DataLoader

import tensorflow as tf

(x_train, y_train), (x_test, y_test) = tf.keras.datasets.mnist.load_data()

# x_train = torch.tensor(x_train.reshape(60000, 784)/255, dtype=torch.float32)
# x_test = torch.tensor(x_test.reshape(10000, 784)/255, dtype=torch.float32)

# y_train = torch.tensor(y_train, dtype=torch.long)
# y_test = torch.tensor(y_test, dtype=torch.int64)

x_train = torch.tensor(x_train/255, dtype=torch.float32)
x_test = torch.tensor(x_test/255, dtype=torch.float32)

y_train = torch.tensor(y_train, dtype=torch.long)
y_test = torch.tensor(y_test, dtype=torch.int64)

x_train.shape

y_train

y_train.unsqueeze(-1)

class TestDataset(Dataset):

    def __init__(self, data):
        self.data_x = data[0]
        self.data_y = data[1]

    def __len__(self):
        return self.data_x.size(0)

    def __getitem__(self, index):
        return self.data_x[index], self.data_y[index]

ds = TestDataset((x_test, y_test))

len(ds)

for i, j in ds:
    print(i.size(), j.size())

ds.__len__()

"""### Our case"""

from torch.utils.data import Dataset, DataLoader

spot.size()

class MyDataset(Dataset):
    def __init__(self, data):
        self.data = torch.cat(data, dim=1)

    def __len__(self):
        return self.data.size(2)

    def __getitem__(self, index):
        return self.data[:, :, index].unsqueeze(1)

lm = moneyness(spot, 1.1)
t = time_to_maturity(spot, 0.004)
v = volatility(spot, 0.2)

ds = MyDataset([lm, t, v])

for i in ds:
    print(i.size())

"""# compute_hedge"""

def compute_hedge(model, ds):
    outputs = []
    for i in ds:
        outputs.append(model(i))

    return torch.cat(outputs, dim=-1)

compute_hedge(m, ds).size()

"""# compute_portfolio"""

def compute_portfolio(model, ds, payoff):

    unit = compute_hedge(model, ds)

    return pl(spot, unit)

compute_portfolio(m, ds, None)

def compute_portfolio_2(model, ds, payoff):

    unit = compute_hedge(model, ds)

    return pl(spot, unit, payoff=payoff)

compute_portfolio_2(m, ds, european_payoff(spot))

"""# Optimizer and Training"""

optimizer = torch.optim.Adam(m.parameters())

for i in range(10):
    optimizer.zero_grad()
    cash = compute_portfolio_2(m, ds, european_payoff(spot))
    loss = torch.mean(cash*cash)
    loss.backward()
    optimizer.step()

    print(loss)

"""# Loss functions"""

x = -torch.arange(4.0)
x

torch.logsumexp(-x, 0) - math.log(x.size(0))

def entropic_risk_measure(x):
    return torch.logsumexp(-x, 0) - math.log(x.size(0))

x = -torch.arange(10.0)
x

torch.topk(x, 6, largest=False)

torch.topk(x, 6, largest=False).values.mean()

torch.topk(x, math.ceil(0.6 * x.numel()), largest=False).values.mean()



"""# Training with entropic risk measure"""

for i in range(10):
    optimizer.zero_grad()
    cash = compute_portfolio_2(m, ds, european_payoff(spot))
    loss = entropic_risk_measure(cash)
    loss.backward()
    optimizer.step()

    print(loss)

"""# prev_hedge"""

from torch import nn

class MLP(nn.Module):

    def __init__(self, n_inputs):
        super().__init__()

        self.model = nn.Sequential(
            nn.Linear(n_inputs, 512),
            nn.ReLU(),
            nn.Linear(512, 512),
            nn.ReLU(),
            nn.Linear(512, 512),
            nn.ReLU(),
            nn.Linear(512,1)
        )

    def forward(self, x):

        out = self.model(x)

        return out

class NewModel(nn.Module):

    def __init__(self, model):
        super().__init__()
        self.model = model
        self.register_buffer("prev_hegde", None)

    def forward(self, x):
        if self.prev_hegde is None:
            self.register_buffer("prev_hedge", torch.zeros(x.size(0), x.size(1), 1))

        new_x = torch.cat([x, self.prev_hedge], dim=-1)
        out = self.model(new_x)
        self.prev_hedge = out.detach()

        return out

mm = NewModel(MLP(4))
mm

for i in range(10):
    optimizer.zero_grad()
    cash = compute_portfolio_2(mm, ds, european_payoff(spot))
    loss = entropic_risk_measure(cash)
    loss.backward()
    optimizer.step()

    print(loss)