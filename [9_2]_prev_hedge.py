# -*- coding: utf-8 -*-
"""[9_2] prev_hedge

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oe40dF1pmaChGX1XvsZT-Gza2IptXQDb
"""

!pip install pfhedge

"""### Last time"""

import pfhedge
import torch
from torch.utils.data import Dataset, DataLoader

from pfhedge.instruments import BrownianStock
from pfhedge.instruments import EuropeanOption
from pfhedge.nn import MultiLayerPerceptron

stock = BrownianStock(cost=0.0001)
derivative = EuropeanOption(stock, strike=1.0)
m = MultiLayerPerceptron(3)

torch.manual_seed(42)

derivative.simulate(2000)
lm = derivative.moneyness()
t = derivative.time_to_maturity()
v = derivative.ul().volatility

class MyDataset(Dataset):
    def __init__(self, data):
        self.data = torch.stack(data, dim=-1)

    def __len__(self):
        return self.data.size(1)

    def __getitem__(self, index):
        return self.data[:, index, :].unsqueeze(1)

ds = MyDataset([lm, t, v])

m

class MLP(torch.nn.Module):

    def __init__(self, model):
        super().__init__()
        self.model = model

    def forward(self, x):
        output = self.model(x)
        return output

mm = MLP(m)
mm

mm(torch.randn(2,3))

def compute_hedge(model, ds):
    outputs = []
    for i in ds:
        outputs.append(model(i))

    return torch.cat(outputs, dim=-1)

compute_hedge(mm, ds)

def compute_portfolio(mm, ds, derivative):

    spot = torch.stack([derivative.ul().spot], dim=1)
    unit = compute_hedge(mm, ds)

    return pfhedge.nn.functional.pl(spot, unit)

compute_portfolio(mm, ds, derivative)

def compute_portfolio_2(mm, ds, derivative):

    spot = torch.stack([derivative.ul().spot], dim=1)
    unit = compute_hedge(mm, ds)

    return pfhedge.nn.functional.pl(spot, unit, payoff=derivative.payoff())

compute_portfolio_2(mm, ds, derivative)

# def fit(mm, ds, derivative):

#     optimizer = torch.optim.Adam(mm.parameters())

#     for i in range(1000):
#         optimizer.zero_grad()
#         cash = compute_portfolio_2(mm, ds, derivative)
#         loss = pfhedge.nn.functional.entropic_risk_measure(cash)
#         loss.backward()
#         optimizer.step()

#         if i % 100 == 0:
#             print(loss)

# fit(mm, ds, derivative)

"""# prev_hedge"""

class MLP(torch.nn.Module):

    def __init__(self, model):
        super().__init__()
        self.model = model
        self.register_buffer("prev_hedge", None)

    def forward(self, x):
        if self.prev_hedge is None:
            self.register_buffer("prev_hedge", torch.zeros(x.size(0), x.size(1), 1))

        new_x = torch.cat([x, self.prev_hedge], dim=-1)

        out = self.model(new_x)

        self.prev_hedge = out.detach()

        return out

mmp = MLP(MultiLayerPerceptron(4))

mmp

def fit(model, ds, derivative):

    optimizer = torch.optim.Adam(model.parameters())

    for i in range(1000):
        optimizer.zero_grad()
        cash = compute_portfolio_2(model, ds, derivative)
        # loss = torch.mean(cash*cash)
        loss = pfhedge.nn.functional.expected_shortfall(cash, 0.5)
        # loss = pfhedge.nn.functional.entropic_risk_measure(cash)
        loss.backward()
        optimizer.step()

        if i % 100 == 0:
            print(loss)

fit(mmp, ds, derivative)

temp = compute_hedge(mmp, ds).squeeze(1).detach().numpy()

temp2 = compute_portfolio_2(mmp, ds, derivative).detach().numpy()

import matplotlib.pyplot as plt

plt.plot(temp2.T)
#plt.ylim(-0.1, 0.1)
plt.show()

plt.hist(temp2.T)
plt.show()

plt.plot(temp[0:100].T)
plt.show()

