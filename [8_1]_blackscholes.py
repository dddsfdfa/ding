# -*- coding: utf-8 -*-
"""[8_1] BlackScholes

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Gh3oGM6EWowmGr85pKSG6bD5rorWFnwS
"""

!pip install pfhedge

"""### Setup"""

import pfhedge
import torch
from torch.utils.data import Dataset, DataLoader

from pfhedge.instruments import BrownianStock
from pfhedge.instruments import EuropeanOption
from pfhedge.nn import BlackScholes

stock = BrownianStock()
derivative = EuropeanOption(stock, strike=1.0)
m = BlackScholes(derivative)

derivative.simulate(2)
lm = derivative.log_moneyness()
t = derivative.time_to_maturity()
v = derivative.ul().volatility

class MyDataset(Dataset):
    def __init__(self, data):
        self.data = torch.stack(data, dim=-1)

    def __len__(self):
        return self.data.size(1)

    def __getitem__(self, index):
        return self.data[:, index, :].unsqueeze(1)

ds = MyDataset([lm, t, v])

m

m.delta()

m.delta(lm, t, v)

for i in ds:
    print(m(i).size())

"""### Shape (or size) is very important!!!"""

pfhedge.nn.functional.pl(stock.spot, m.delta())

"""### pfhedge.nn.modules.hedger.compute_hedge"""

from pfhedge.instruments import BaseInstrument, BaseDerivative
from torch import Tensor
from typing import Optional
from typing import List

def compute_hedge(
        self, derivative: BaseDerivative, hedge: Optional[List[BaseInstrument]] = None
    ) -> Tensor:

        inputs = self.inputs.of(derivative, self)
        hedge = self._get_hedge(derivative, hedge)

        # Check that the spot prices of the hedges have the same sizes
        if not all(h.spot.size() == hedge[0].spot.size() for h in hedge):
            raise ValueError("The spot prices of the hedges must have the same size")

        (n_paths, n_steps), n_hedges = hedge[0].spot.size(), len(hedge)
        if inputs.is_state_dependent():
            zeros = hedge[0].spot.new_zeros((n_paths, 1, n_hedges))
            save_prev_output(self, input=(), output=zeros)
            outputs = []
            for time_step in range(n_steps - 1):
                input = inputs.get(time_step)  # (N, T=1, F)
                outputs.append(self(input))  # (N, T=1, H)
            outputs.append(outputs[-1])
            output = torch.cat(outputs, dim=-2)  # (N, T, H)
        else:
            # If all features are state-independent, compute the output at all
            # time steps at once, which would be faster.
            input = inputs.get(None)  # (N, T, F)
            output = self(input)  # (N, T, H)
            # This maintains consistency with the previous implementations.
            # In previous implementation the loop is computed for 0...T-2 and
            # the last time step is not included.
            output[..., -1, :] = output[..., -2, :]

        output = output.transpose(-1, -2)  # (N, H, T)

        return output

from pfhedge.nn import Hedger
hedger = Hedger()

hedger.__call__()

torch.nn.Module

hedger.forward()

for i in ds:
    print(i.size())

outputs = []
for i in ds:
    outputs.append(m(i))

outputs = torch.cat(outputs, dim=-2)
# outputs = outputs.transpose(-1,-2)
outputs

outputs = []
for i in ds:
    outputs.append(m(i))

outputs = torch.cat(outputs, dim=-1)
outputs

"""### check"""

from pfhedge.instruments import BrownianStock
from pfhedge.instruments import EuropeanOption
from pfhedge.nn import BlackScholes

_ = torch.manual_seed(42)

derivative = EuropeanOption(BrownianStock(), maturity=5/250)

derivative.simulate(2)

derivative.ul().spot

model = BlackScholes(derivative)

from pfhedge.nn import Hedger

hedger = Hedger(model, model.inputs())

hedger.compute_hedge(derivative).squeeze(1)

hedger.compute_portfolio(derivative)

"""### Our version"""

lm = derivative.log_moneyness()
t = derivative.time_to_maturity()
v = derivative.ul().volatility

ds = MyDataset([lm, t, v])

outputs = []
for i in ds:
    outputs.append(m(i))

outputs = torch.cat(outputs, dim=-1)
outputs.squeeze(1)

spot = torch.stack([derivative.ul().spot], dim=1)

spot.size()

pfhedge.nn.functional.pl(spot, outputs)

"""### Final step"""

derivative.payoff()

pfhedge.nn.functional.pl(spot, outputs, payoff=derivative.payoff())

hedger.compute_pl(derivative)

hedger.price(derivative, n_paths=2)

hedger.criterion.cash(hedger.compute_portfolio(derivative), derivative.payoff())

"""# For the next step"""

def compute_hedge(model, ds):
    outputs = []
    for i in ds:
        outputs.append(model(i))

    return torch.cat(outputs, dim=-1)

def compute_portfolio(model, ds, derivative):

    spot = torch.stack([derivative.ul().spot], dim=1)
    unit = compute_hedge(model, ds)

    return pfhedge.nn.functional.pl(spot, unit)

def compute_portfolio_2(model, ds, derivative):

    spot = torch.stack([derivative.ul().spot], dim=1)
    unit = compute_hedge(model, ds)

    return pfhedge.nn.functional.pl(spot, unit, payoff=derivative.payoff())

