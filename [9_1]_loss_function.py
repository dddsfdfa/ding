# -*- coding: utf-8 -*-
"""[9_1] loss function

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qmehjr7bJiGR2Qtng2TmI0OPWYlfQGrg
"""

!pip install pfhedge

"""### Last time"""

import pfhedge
import torch
from torch.utils.data import Dataset, DataLoader

from pfhedge.instruments import BrownianStock
from pfhedge.instruments import EuropeanOption
from pfhedge.nn import MultiLayerPerceptron

stock = BrownianStock(cost=0.001)
derivative = EuropeanOption(stock, strike=1.0)
m = MultiLayerPerceptron(3)

class MyDataset(Dataset):
    def __init__(self, data):
        self.data = torch.stack(data, dim=-1)

    def __len__(self):
        return self.data.size(1)

    def __getitem__(self, index):
        return self.data[:, index, :].unsqueeze(1)

torch.manual_seed(42)

derivative.simulate(2000)
lm = derivative.moneyness()
t = derivative.time_to_maturity()
v = derivative.ul().volatility

ds = MyDataset([lm, t, v])

class MLP(torch.nn.Module):

    def __init__(self, model):
        super().__init__()
        self.model = model

    def forward(self, x):
        output = self.model(x)
        return output

mm = MLP(m)
mm

for i in mm.parameters():
    print(i)

sum(p.numel() for p in mm.parameters())

"""### compute_hedge"""

def compute_hedge(model, ds):
    outputs = []
    for i in ds:
        out = model(i)
        outputs.append(out)

    return torch.cat(outputs, dim=-1)

compute_hedge(mm, ds)

"""### compute_portfolio"""

def compute_portfolio(model, ds, derivative):

    spot = torch.stack([derivative.ul().spot], dim=1)
    unit = compute_hedge(model, ds)

    return pfhedge.nn.functional.pl(spot, unit)

compute_portfolio(mm, ds, derivative)

def compute_portfolio_2(model, ds, derivative):

    spot = torch.stack([derivative.ul().spot], dim=1)
    unit = compute_hedge(model, ds)

    return pfhedge.nn.functional.pl(spot, unit, payoff=derivative.payoff())

compute_portfolio_2(mm, ds, derivative)

"""### fit()"""

def fit(model, ds, derivative):

    optimizer = torch.optim.Adam(model.parameters())

    for i in range(1000):
        optimizer.zero_grad()
        cash = compute_portfolio_2(model, ds, derivative)
        # loss = torch.sum(cash*cash)
        loss = pfhedge.nn.functional.entropic_risk_measure(cash)
        #loss = pfhedge.nn.functional.expected_shortfall(cash, 0.8)
        loss.backward()
        optimizer.step()

        if i % 100 == 0:
            print(loss)

fit(mm, ds, derivative)

"""### How good is it?"""

import matplotlib.pyplot as plt

temp = compute_hedge(mm, ds)
temp.size()

plt.plot(temp.squeeze(1).detach().numpy()[0:10].T)
#plt.ylim(-1,1)
plt.show()

temp_2 = compute_portfolio_2(mm, ds, derivative)
temp_2.size()

plt.plot(temp_2.detach().numpy())
#plt.ylim(-0.1, 0.1)
plt.show()

plt.hist(temp_2.detach().numpy())
#plt.xlim(-0.1, 0.1)
plt.show()

