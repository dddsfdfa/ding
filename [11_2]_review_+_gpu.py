# -*- coding: utf-8 -*-
"""[11_2] review + GPU

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hGZn6bTxPoxfsxlvLo_tz3gAsbKD8lU7
"""

import torch
import math

# Check if CUDA (GPU) is available
if torch.cuda.is_available():
    print("CUDA is available. You can use the GPU!")
else:
    print("CUDA is not available. Using the CPU instead.")

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

"""# Brownian Motion"""

def generate_brownian(n_paths, n_steps):

    dW = torch.randn(n_paths, n_steps)
    dW[:, 0] = 0.0
    W = dW.cumsum(dim=-1)

    return W

generate_brownian(2,5)

def generate_geometric_brownian(n_paths=2, n_steps=5, sigma=0.2, dt=1/250):

    t = torch.arange(n_steps) * dt
    W = generate_brownian(n_paths, n_steps)

    return torch.exp((-0.5 * sigma**2) * t + sigma *  torch.sqrt(torch.tensor(dt)) * W)

generate_geometric_brownian()

"""# Derivative payoff"""

def european_payoff(input, call=True, strike=1.0):

    if call:
        return torch.nn.functional.relu(input[..., -1] - strike)
    else:
        return torch.nn.functional.relu(strike - input[..., -1])

spot = generate_geometric_brownian(2000, 251).unsqueeze(1)
spot

payoff = european_payoff(spot)
payoff

"""# profit and loss function (pl)"""

def pl(spot, unit, cost=None, payoff=None):

    output = unit[..., :-1].mul(spot.diff(dim=-1)).sum(dim=(-2,-1))

    if payoff is not None:
        output -= payoff.squeeze(-1)

    if cost is not None:
        c = torch.tensor(cost).unsqueeze(0).unsqueeze(-1)
        output -= (spot[..., :-1].mul(unit.diff(dim=-1)).abs() * c).sum(dim=(-2, -1))

    return output

unit = torch.randn_like(spot)
unit

pl(spot, unit, cost=0.1)

pl(spot, unit, cost= 0.1, payoff=payoff)

"""# Features"""

def time_to_maturity(spot, dt):

    n_paths, _, n_steps = spot.size()
    t = torch.arange(n_steps) * dt

    return (t[-1] - t).unsqueeze(0).expand(n_paths, 1, -1)

time_to_maturity(spot, 0.004)

def moneyness(spot, strike):
    return spot/strike

moneyness(spot, 1.1)

def log_moneyness(spot, strike):
    return torch.log(spot/strike)

log_moneyness(spot, 1.0)

def volatility(spot, vol):
    return torch.ones_like(spot) * vol

volatility(spot, 0.2)

"""# MLP"""

from torch import nn

class MLP(nn.Module):

    def __init__(self, n_inputs):
        super().__init__()

        self.model = nn.Sequential(
            nn.Linear(n_inputs, 512),
            nn.ReLU(),
            nn.Linear(512, 512),
            nn.ReLU(),
            nn.Linear(512, 512),
            nn.ReLU(),
            nn.Linear(512,1)
        )

    def forward(self, x):

        out = self.model(x)

        return out

m = MLP(3).to(device)

m

x = torch.randn(3).to(device)
m(x)

"""# Dataset"""

from torch.utils.data import Dataset, DataLoader

spot.size()

class MyDataset(Dataset):
    def __init__(self, data):
        self.data = torch.cat(data, dim=1)

    def __len__(self):
        return self.data.size(2)

    def __getitem__(self, index):
        return self.data[:, :, index].unsqueeze(1).to(device)

lm = moneyness(spot, 1.1)
t = time_to_maturity(spot, 0.004)
v = volatility(spot, 0.2)

ds = MyDataset([lm, t, v])

for i in ds:
    print(i)

"""# compute_hedge"""

def compute_hedge(model, ds):
    outputs = []
    for i in ds:
        outputs.append(model(i))

    return torch.cat(outputs, dim=-1)

compute_hedge(m, ds)

"""# compute_portfolio"""

def compute_portfolio(model, ds, payoff):

    unit = compute_hedge(model, ds)

    return pl(spot.to(device), unit)

compute_portfolio(m, ds, None)

def compute_portfolio_2(model, ds, payoff):

    unit = compute_hedge(model, ds)

    return pl(spot.to(device), unit, payoff=payoff.to(device))

compute_portfolio_2(m, ds, european_payoff(spot))

"""# Optimizer and Training"""

optimizer = torch.optim.Adam(m.parameters())

"""# Loss functions"""

def entropic_risk_measure(x):
    return torch.logsumexp(-x, -1) - math.log(x.size(0))

"""# Training with entropic risk measure"""

for i in range(10):
    optimizer.zero_grad()
    cash = compute_portfolio_2(m, ds, european_payoff(spot))
    loss = entropic_risk_measure(cash)
    loss.backward()
    optimizer.step()

    print(loss)

"""# prev_hedge"""

from torch import nn

class MLP(nn.Module):

    def __init__(self, n_inputs):
        super().__init__()

        self.model = nn.Sequential(
            nn.Linear(n_inputs, 512),
            nn.ReLU(),
            nn.Linear(512, 512),
            nn.ReLU(),
            nn.Linear(512, 512),
            nn.ReLU(),
            nn.Linear(512,1)
        )

    def forward(self, x):

        out = self.model(x)

        return out

class NewModel(nn.Module):

    def __init__(self, model):
        super().__init__()
        self.model = model
        self.register_buffer("prev_hegde", None)

    def forward(self, x):
        if self.prev_hegde is None:
            self.register_buffer("prev_hedge", torch.zeros(x.size(0), x.size(1), 1).to(device))

        new_x = torch.cat([x, self.prev_hedge], dim=-1)
        out = self.model(new_x)
        self.prev_hedge = out.detach()

        return out

mm = NewModel(MLP(4)).to(device)
mm

for i in range(1000):
    optimizer.zero_grad()
    cash = compute_portfolio_2(mm, ds, european_payoff(spot))
    loss = entropic_risk_measure(cash)
    loss.backward()
    optimizer.step()

    if i % 100 == 0:
        print(loss)

