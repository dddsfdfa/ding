# -*- coding: utf-8 -*-
"""[7_2] torch.utils.data.dataset

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1z4_XOb20KqIwGeKCu9_WcbkixikBfkCq
"""

!pip install pfhedge

"""### Last time

```
pfhedge.nn.functional.pl(stock.spot.unsqueeze(1), m(input).squeeze(-1).unsqueeze(1))
```

### Setup
"""

import pfhedge

from pfhedge.instruments import BrownianStock
from pfhedge.instruments import EuropeanOption
from pfhedge.nn import BlackScholes

stock = BrownianStock()
derivative = EuropeanOption(stock, strike=1.0)
derivative

m = BlackScholes(derivative)
m

"""### Features"""

stock.simulate()

stock.spot

derivative.simulate()

stock.spot

derivative.ul()

derivative.ul().spot

derivative.log_moneyness()

derivative.time_to_maturity()

derivative.ul().volatility

"""### Dataset Manipulation"""

derivative.simulate(2)

lm = derivative.log_moneyness()
t = derivative.time_to_maturity()
v = derivative.ul().volatility

"""### torch.stack vs. torch.cat
[ChaptGPT] torch.stack vs. torch.cat
"""

import torch

lm.size(), t.size(), v.size()

torch.stack([lm, t, v]).size()

torch.cat([lm, t, v]).size()

torch.stack([lm, t, v], dim=-1).size()

torch.cat([lm, t, v], dim=-1).size()

torch.cat([lm.unsqueeze(-1), t.unsqueeze(-1), v.unsqueeze(-1)], dim=2).size()

lm.unsqueeze(-1).size()

"""### Back to the topic"""

torch.stack([lm, t, v], dim=-1).size()

torch.stack([lm, t, v], dim=-1)

"""### torch.utils.data"""

import torch
from torch.utils.data import Dataset, DataLoader

class MyDataset(Dataset):

    def __init__(self, data):
        self.data = data

    def __len__(self):
        return len(self.data)

    def __getitem__(self, index):
        return self.data[index]

ds = MyDataset(lm)

len(ds)

ds

ids = iter(ds)

next(ids)

"""### updated version"""

class MyDataset(Dataset):

    def __init__(self, data):
        self.data = data

    def __len__(self):
        return self.data.size(1)

    def __getitem__(self, index):
        return self.data[:,index]

ds = MyDataset(lm)

for i in ds:
    print(i)
    print("----")

ds = MyDataset(torch.stack([lm, t, v], dim=-1))

len(ds)

for i in ds:
    print(i)

"""### updated version 2"""

class MyDataset(Dataset):
    def __init__(self, data):
        self.data = torch.stack(data, dim=-1)

    def __len__(self):
        return self.data.size(1)

    def __getitem__(self, index):
        #return self.data[:, index, :]
        return self.data[:, index, :].unsqueeze(1)

ds = MyDataset([lm, t, v])

for i in ds:
    print(i)

"""### Black-Scholes"""

from pfhedge.nn import BlackScholes

m = BlackScholes(derivative)

"""[european.py](https://github.com/pfnet-research/pfhedge/blob/main/pfhedge/nn/modules/bs/european.py#L106)"""

m

m.delta()

m.delta(lm, t, v)

for i in ds:
    print(m(i))

pfhedge.nn.functional.pl(stock.spot, m.delta())

"""### pfhedge.nn.functional.pl"""

from torch import Tensor
from typing import Optional
from typing import List

def pl(
    spot: Tensor,
    unit: Tensor,
    cost: Optional[List[float]] = None,
    payoff: Optional[Tensor] = None,
    deduct_first_cost: bool = True,
    deduct_final_cost: bool = False,
) -> Tensor:
    r"""Returns the final profit and loss of hedging.

    For
    hedging instruments indexed by :math:`h = 1, \dots, H` and
    time steps :math:`i = 1, \dots, T`,
    the final profit and loss is given by

    .. math::
        \text{PL}(Z, \delta, S) =
            - Z
            + \sum_{h = 1}^{H} \sum_{t = 1}^{T} \left[
                    \delta^{(h)}_{t - 1} (S^{(h)}_{t} - S^{(h)}_{t - 1})
                    - c^{(h)} |\delta^{(h)}_{t} - \delta^{(h)}_{t - 1}| S^{(h)}_{t}
                \right] ,

    where
    :math:`Z` is the payoff of the derivative.
    For each hedging instrument,
    :math:`\{S^{(h)}_t ; t = 1, \dots, T\}` is the spot price,
    :math:`\{\delta^{(h)}_t ; t = 1, \dots, T\}` is the number of shares
    held at each time step.
    We define :math:`\delta^{(h)}_0 = 0` for notational convenience.

    A hedger sells the derivative to its customer and
    obliges to settle the payoff at maturity.
    The dealer hedges the risk of this liability
    by trading the underlying instrument of the derivative.
    The resulting profit and loss is obtained by adding up the payoff to the
    customer, capital gains from the underlying asset, and the transaction cost.

    References:
        - Buehler, H., Gonon, L., Teichmann, J. and Wood, B., 2019.
          Deep hedging. Quantitative Finance, 19(8), pp.1271-1291.
          [arXiv:`1802.03042 <https://arxiv.org/abs/1802.03042>`_ [q-fin]]

    Args:
        spot (torch.Tensor): The spot price of the underlying asset :math:`S`.
        unit (torch.Tensor): The signed number of shares of the underlying asset
            :math:`\delta`.
        cost (list[float], default=None): The proportional transaction cost rate of
            the underlying assets.
        payoff (torch.Tensor, optional): The payoff of the derivative :math:`Z`.
        deduct_first_cost (bool, default=True): Whether to deduct the transaction
            cost of the stock at the first time step.
            If ``False``, :math:`- c |\delta_0| S_1` is omitted the above
            equation of the terminal value.

    Shape:
        - spot: :math:`(N, H, T)` where
          :math:`N` is the number of paths,
          :math:`H` is the number of hedging instruments, and
          :math:`T` is the number of time steps.
        - unit: :math:`(N, H, T)`
        - payoff: :math:`(N)`
        - output: :math:`(N)`.

    Returns:
        torch.Tensor
    """
    # TODO(simaki): Support deduct_final_cost=True
    assert not deduct_final_cost, "not supported"

    if spot.size() != unit.size():
        raise RuntimeError(f"unmatched sizes: spot {spot.size()}, unit {unit.size()}")
    if payoff is not None:
        if payoff.dim() != 1 or spot.size(0) != payoff.size(0):
            raise RuntimeError(
                f"unmatched sizes: spot {spot.size()}, payoff {payoff.size()}"
            )

    output = unit[..., :-1].mul(spot.diff(dim=-1)).sum(dim=(-2, -1))

    if payoff is not None:
        output -= payoff

    if cost is not None:
        c = torch.tensor(cost).to(spot).unsqueeze(0).unsqueeze(-1)
        output -= (spot[..., 1:] * unit.diff(dim=-1).abs() * c).sum(dim=(-2, -1))
        if deduct_first_cost:
            output -= (spot[..., [0]] * unit[..., [0]].abs() * c).sum(dim=(-2, -1))

    return output

stock.spot.size()

spot = torch.stack([stock.spot], dim=1)
spot.size()

m.delta().size()

m.delta().unsqueeze(1).size()

pl(spot, m.delta().unsqueeze(1))

outputs = []
for i in ds:
    outputs.append(m(i))

outputs = torch.cat(outputs, dim=-2)
outputs = outputs.transpose(-1,-2)
outputs

output = unit[..., :-1].mul(spot.diff(dim=-1)).sum(dim=(-2, -1))

spot.size()

outputs.size()

unit = outputs

unit[..., :-1]

unit[..., :-1].mul(spot.diff(dim=-1)).sum(dim=(-2, -1)).size()

