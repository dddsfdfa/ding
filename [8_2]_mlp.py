# -*- coding: utf-8 -*-
"""[8_2] MLP

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1X2IIj9jO1EFtgA_aQyBWTrR6rOC3tGBA
"""

!pip install pfhedge

"""### Last time"""

import pfhedge
import torch
from torch.utils.data import Dataset, DataLoader

from pfhedge.instruments import BrownianStock
from pfhedge.instruments import EuropeanOption
from pfhedge.nn import BlackScholes

stock = BrownianStock()
derivative = EuropeanOption(stock, strike=1.0)
m = BlackScholes(derivative)

derivative.simulate(2)
lm = derivative.log_moneyness()
t = derivative.time_to_maturity()
v = derivative.ul().volatility

class MyDataset(Dataset):
    def __init__(self, data):
        self.data = torch.stack(data, dim=-1)

    def __len__(self):
        return self.data.size(1)

    def __getitem__(self, index):
        return self.data[:, index, :].unsqueeze(1)

ds = MyDataset([lm, t, v])

outputs = []
for i in ds:
    outputs.append(m(i))

outputs = torch.cat(outputs, dim=-1)
outputs

spot = torch.stack([derivative.ul().spot], dim=1)

pfhedge.nn.functional.pl(spot, outputs, payoff=derivative.payoff())

"""### MLP

"""

import pfhedge
import torch
from torch.utils.data import Dataset, DataLoader

from pfhedge.instruments import BrownianStock
from pfhedge.instruments import EuropeanOption
from pfhedge.nn import MultiLayerPerceptron

stock = BrownianStock()
derivative = EuropeanOption(stock, strike=1.0)
m = MultiLayerPerceptron(3)

derivative.simulate(2)
lm = derivative.moneyness() # <- Note that this is not log moneyness
t = derivative.time_to_maturity()
v = derivative.ul().volatility

class MyDataset(Dataset):
    def __init__(self, data):
        self.data = torch.stack(data, dim=-1)

    def __len__(self):
        return self.data.size(1)

    def __getitem__(self, index):
        return self.data[:, index, :].unsqueeze(1)

ds = MyDataset([lm, t, v])

m

"""### Simple model"""

class MLP(torch.nn.Module):

    def __init__(self, model):
        super().__init__()
        self.model = model

    def forward(self, x):
        output = self.model(x)
        return output

mm = MLP(m)
mm

mm(torch.randn(2,3))

for i in ds:
    print(mm(i))

outputs = []
for i in ds:
    outputs.append(mm(i))

outputs = torch.cat(outputs, dim=-1)
outputs

spot = torch.stack([derivative.ul().spot], dim=1)

pfhedge.nn.functional.pl(spot, outputs, payoff=derivative.payoff())

"""# Training"""

epochs = 2

for i in range(epochs):
    outputs = []
    for j in ds:
        outputs.append(mm(j))

    outputs = torch.cat(outputs, dim=-1)
    print(outputs)

"""### compute_hedge"""

def compute_hedge(model, ds):
    outputs = []
    for i in ds:
        outputs.append(model(i))

    return torch.cat(outputs, dim=-1)

compute_hedge(mm, ds)

"""### compute_portfolio"""

def compute_portfolio(model, ds, derivative):

    spot = torch.stack([derivative.ul().spot], dim=1)
    unit = compute_hedge(model, ds)

    return pfhedge.nn.functional.pl(spot, unit)

compute_portfolio(mm, ds, derivative)

def compute_portfolio_2(model, ds, derivative):

    spot = torch.stack([derivative.ul().spot], dim=1)
    unit = compute_hedge(model, ds)

    return pfhedge.nn.functional.pl(spot, unit, payoff=derivative.payoff())

compute_portfolio_2(mm, ds, derivative)

"""### fit()"""

def fit(model, ds, derivative):

    optimizer = torch.optim.Adam(model.parameters())

    for i in range(100):
        optimizer.zero_grad()
        cash = compute_portfolio_2(model, ds, derivative)
        loss = torch.mean(cash)
        loss.backward()
        optimizer.step()

        if i % 1 == 0:
            print(loss)

fit(mm, ds, derivative)

"""### bigger dataset"""

derivative.simulate(2000)
lm = derivative.moneyness()
t = derivative.time_to_maturity()
v = derivative.ul().volatility

ds = MyDataset([lm, t, v])

compute_hedge(mm, ds)

